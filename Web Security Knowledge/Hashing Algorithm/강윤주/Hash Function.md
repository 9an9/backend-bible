# Hash Function(해시 함수)

- 임의의 길이를 갖는 임의의 데이터에 대해 고정된 길이의 데이터로 매핑하는 함수
  - 매핑 전 원래 데이터 값 : 키(key)
  - 매핑 후 데이터 값 : 해시 값(hash value)
  - 해시 값 + 데이터의 색인 주소 : 해시 테이블(hash table)
  - 매핑하는 과정 : 해싱(hashing)

- 알고리즘이 복잡하지 않기 때문에 상대적으로 CPU, 메모리와 같은 시스템 자원을 덜 소모한다.
- 같은 입력값에 대해서 같은 출력 값이 보장되며, <span style="background-color:#C3E7FA">이 출력 값은 가능한 한 고른 범위에 균일하게 분포하는 특성이 있다.</span><sub>(이 특성이 어떤 의미인지, 어떤 영향을 미치는지)</sub>

- 해시값을 생성하는 원본과 별도의 값을 입력받아서 같은 입력에 대해 다른 출력 값을 갖게 하는 해시 함수도 존재한다.
- 해시 함수는 보통 입력 값의 범위보다 출력 값의 범위가 좁은 경우가 많기 때문에 입력이 다름에도 불구하고 드물게 동일한 값이 출력되는 경우가 존재한다. 이러한 경우를 **충돌** 이라 한다. 원칙적으로 해시 함수는 불가피한 충돌을 제외하고 의도적으로 충돌을 계산해낼 수 없어야 한다.

#### 사용 예시

- 비밀번호 저장 용도
- 복제문서인지 판별
- 검색 용도

### 해시 자료구조

- 효율적인 데이터 관리
  - 해시 충돌이 발생할 가능성이 있음에도 해시 테이블을 쓰는 이유는 적은 리소스로 많은 데이터를 효율적으로 관리하기 위해서이다.
  - 해시 함수로 하드디스크나 클라우드에 존재하는 무한에 가까운 데이터(키)들을 유한한 개수의 해시값으로 매핑함으로써 작은 크기의 캐쉬 메모리로도 프로세스를 관리할 수 있게 된다.
- 빠른 데이터 처리
  - 색인(index)에 해시값을 사용함으로써 (정렬을 하지 않고) 모든 데이터를 살피지 않아도 검색과 삽입/삭제를 빠르게 수행할 수 있다.
  - 해시 함수는 언제나 동일한 해시값을 리턴하고, 해당 색인만 알면 해시 테이블의 크기에 상관없이 데이터에 대단히 빠르게 접근할 수 있으며, 색인은 계산이 간단한 함수(상수시간)로 작동하기 때문에 매우 효율적이다. 데이터 액세스(삽입/삭제/탐색)시 계산 복잡성을 O(1)을 지향한다.

### 해시 테이블

- 해시는 리스트를 사용하는 접근법은 동일하지만 여기에 색인(index) 개념이 추가되어 있다.
- 충분히 큰 공간을 할당받은 다음 해시 함수를 이용하여 고유 색인을 생성한다.
- 그리고 이 고유 색인과 맞는 위치에 데이터를 저장한다.
- 해쉬 함수를 사용하여 키를 해시값으로 매핑하고, 이 해시값의 색인 주소 값과 키를 함께 저장하는 자료구조를 **해시 테이블(hash table)**이라고 한다.
- 색인 주소 값의 데이터가 저장되는 곳을 버킷(bucket) 또는 슬롯(slot)이라고 한다.
- 키의 전체 개수와 동일한 크기의 버킷을 가진 해시 테이블을 **Direct-address table**이라고 한다.
  - 키 개수와 해시테이블의 크기가 동일하기 때문에 해시충돌 문제가 발생하지 않는다.
  - 실제 사용하는 키(actual keys)가 전체 키(inverse of keys)보다 적을 경우 사용하지 않는 키들을 위한 공간까지 마련해야 하기 때문에 메모리 효율성이 크게 떨어진다.
  - Direct-address table의 메모리 효율성 문제로 보통은 **해시테이블 크기(m)가 실제 사용하는 키 개수(n)보다 적은** 해시테이블을 운용한다.

### 해시 충돌

- 해시는 비밀번호, 전자서명, 전자투표, 전자상거래와 같은 민감한 입력의 무결성을 검증할 때 사용된다.
- 따라서 어떤 해시 함수에서 해시 충돌이 일어나기 쉽다는 것은 보안 분야에서는 매우 민감한 문제이다. 데이터의 무결성과 직접적인 연관이 있기 때문이다.
  - 현재까지 개발된 거의 모든 해시 함수는 해시 충돌의 문제가 확인된 상태이다. SHA-1과 SHA-256, SHA-512는 해시 충돌의 가능성이 이론적으로 제시되었다. 2014년 기준으로 문제가 없는 해시 표준으로는 SHA-3가 유일하다.

#### 해결방법

- 분리 연결법(Separate Chaining)
- 개방 주소법(Open Addressing)
- 리스트 크기 재배열
- 해시 테이블 확장 방식
- Consistent Hashing - 해시의 비트수를 늘이는 방법
- 해시 함수를 이용한 해시 충돌 해결



## 해시 함수

### 단방향 해시함수

- 단방향 해시함수는 수학적인 연산을 통해 원본 메시지를 변환하여 암호화된 메시지인 **다이제스트**를 생성한다.

- 원본 메시지를 알면 암호화된 메시지를 구하기는 쉽지만 암호화된 메시지로는 원본 메시지를 구할 수 없어야 하며 이를 **'단방향성'**이라고 한다.

- 문제점

  - 인식 가능성(recognizability) : 동일한 메시지가 언제나 동일한 다이제스트를 갖는다면, 공격자가 전처리된 다이제스트를 가능한 한 많이 확보한 다음 이를 탈취한 다이제스트와 비교해 원본 메시지를 찾아내거나 동일한 효과의 메시지를 찾을 수 있다. 이와 같은 다이테스트 목록을 **레인보우 테이블(rainbow table)**이라고 하며 이와 같은 공격 방식을 **레인보우 공격(rainbow attack)**이라고 한다. 게다가 다른 사용자의 패스워드가 같으면 다이제스트도 같으므로 한꺼번에 모두 정보가 탈취될 수 있다.
  - 속도(speed) : 해시 함수는 원래 짧은 시간에 데이터를 검색하기 위해 설계된 것이다. 해시 함수의 빠른 처리 속도로 인해 공격자는 매우 빠른 속도로 임의의 문자열의 다이제스트와 해킹할 대상의 다이제스트를 비교할 수 있다.(MD5를 사용한 경우 일반적인 장비를 이용하여 1초당 56억 개의 다이제스트를 대입할 수 있다.) 이처럼 해시함수의 빠른 처리 속도는 사용자들보다 공격자들에게 더 큰 편의성을 제공하게 된다.

  #### 보완

  - 솔팅(salting) 
    - 솔트(salt)는 단방향 해시 함수에서 다이제스트를 생성할 때 추가되는 바이트 단위의 임의의 문자열이다. 원본 메시지에 문자열을 추가하여 다이제스트를 생성하는 것을 솔팅(salting)이라고 한다.
    - 공격자가 메시지의 다이제스트를 알아내더라도 솔팅된 다이제스트를 대상으로 메시지 일치 여부를 확인하기 어렵다.
    - 사용자별로 다른 솔트를 사용한다면 동일한 패스워드를 사용하는 사용자의 다이제스트가 다르게 생성되어 인식 가능성 문제가 개선된다.
    - 솔트와 메시지의 다이제스트를 데이터베이스에 저장하고, 사용자가 입력한 메시지를 해시하여 일치 여부를 확인할 수 있다. 
    - 이 방법을 사용할 때는 모든 패스워드가 고유의 솔트를 갖고 솔트의 길이는 32바이트 이상이어야 솔트와 다이제스트를 추측하기 어렵다.
  - 키 스트레칭(key stretching)
    - 입력한 데이터로 다이제스트를 생성하고, 이를 입력값으로 다시 다이제스트를 생성하는 것을 반복하는 방법으로 다이제스트를 생성한다. 이렇게 하면 입력한 패스워드를 동일한 횟수만큼 해시해야만 입력한 패스워드의 일치 여부를 확인할 수 있다.
    - 잘 설계된 패스워드 저장 시스템에서는 하나의 다이제스트를 생성할 때 어느 정도의 시간이 소요되게 설정한다. 이는 억지 기법 공격으로 패스워드를 추측하는 데 많은 시간이 소요되도록 하기 위한 것이다.



## 알고리즘

1. MD5(Message-Digest Algorithm)

- 임의의 길이의 값을 입력받아서 128비트 길이의 해시 값을 출력하는 함수

2. SHA(Secure Hash Algorithm)

- 미국 NSA가 제작하고 미국 국립표준기술연구소(NIST)에서 표준으로 채택한 암호학적 해시 함수
- SHA-0, SHA-1은 160비트 해시값을 사용하며 해시 충돌의 위험성이 발견되어 SHA-2 버전이 발표되었다.
- 해시 길이에 따라 SHA-225, SHA-256, SHA-384, SHA-512 비트를 선택해서 사용할 수 있으며, 해시 길이가 길수록 더 안전하다.
- 2012년 10월에 더 안정성이 높은 방식으로 설계된 SHA-3이 발표되었다.

##### 참고

https://yjshin.tistory.com/entry/암호학-해시-함수-작성-중

https://junho94.tistory.com/m/30