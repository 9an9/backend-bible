# 가상 메모리

운영체제는 CPU에서 당장 수행해야 할 부분만을 메모리에 올려놓고 그렇지 않은 부분은 디스크의 스왑 영역에 내려놓았다가 필요해지면 메모리에 올라가 있는 부분과 교체하는 방식을 사용한다. -> 물리적 메모리 크기에 대한 제약을 고려하지 않아도 된다.

프로그램이 물리적 메모리를 고려할 필요 없이 자기 자신만이 메모리를 사용하는 것처럼 가정해 프로그램하는 것을 지원한다.

가상 메모리 : 프로그램은 0번지부터 시작하는 자기 자신만의 메모리 주소 공간을 가정할 수 있는데 이 메모리 공간을 가상 메모리라고 한다.

가상 메모리는 프로세스마다 각각 0번지부터의 주소 공간을 가지게 되며 이들 공간 중 일부는 물리적 메모리에 적재되고 일부는 디스크의 스왑 영역에 존재하게 된다. 

프로세스의 주소 공간을 메모리로 적재하는 단위에 따라 가상 메모리 기법은 

요구 페이징 방식과 요구 세그먼테이션 방식으로 구현될 수 있다.

대부분의 경우 요구 페이징 방식을 사용하며 요구 세그먼테이션 방식을 사용하는 경우는 대개 페이지드 세그먼테이션 기법을 사용하는 경우이다.

### 1. 요구 페이징

- 프로그램 실행 시 프로세스를 구성하는 모든 페이지를 한꺼번에 메모리에 올리는 것이 아니라 당장 사용될 페이지만을 올리는 방식
- 특정 페이지에 대해 CPU의 요청이 들어온 후에야 해당 페이지를 메모리에 적재
- 메모리 사용량이 감소하고 프로세스 전체를 메모리에 올리는 데 소요되는 입출력 오버헤드도 줄어든다.
- 사용되지 않을 주소 영역에 대한 입출력까지 수행하던 기존 방식에 비해 응답시간을 단축시킬 수 있으며 시스템이 더 많은 프로세스를 수용할 수 있게 해준다.
- 프로그램이 물리적 메모리의 용량 제약을 벗어날 수 있도록 해준다.특정 프로세스를 구성하는 페이지 중에서 어떤 페이지가 메모리에 존재하고 어떤 페이지가 메모리에 존재하지 않는지 구별하기 위한 방안 필요
- 유효-무효 비트를 두어 각 페이지가 메모리에 존재하는지 표시
  - 각 프로세스를 구성하는 모든 페이지에 대해 존재해야 하므로 페이지 테이블의 각 항목별로 저장됨
  - 유효-무효 비트의 값이 무효인 경우는 페이지가 현재 메모리에 없는 경우뿐만 아니라 그 페이지가 속한 주소 영역을 프로세스가 사용하지 않는 경우도 있음
  - CPU가 참조하려는 페이지가 현재 메모리에 올라와 있지 않아 유효-무효 비트가 무효로 세팅되어 있는 경우를 '페이지 부재'가 일어났다고 함

#### 요구 페이징의 페이지 부재 처리

- CPU가 무효 페이지에 접근하면 주소 변환을 담당하는 하드웨어인 MMU가 페이지 부재 트랩을 발생시키게 된다.
- CPU의 제어권이 커널모드로 전환되고 운영체제의 페이지 부재 처리루틴이 호출된다.
  - 부재 상태의 페이지를 메모리에 적재하기에 앞서 해당 페이지에 대한 접근이 적법한지를 먼저 체크한다.
  - 사용되지 않는 주소 영역에 속한 페이지에 접근하려 했거나 해당 페이지에 대한 접근 권한 위반을 했을 경우에는 해당 프로세스를 종료시킨다
- 해당 페이지에 대한 접근이 적법한 것으로 판명된 경우 물리적 메모리에서 비어 있는 프레임이 없다면 기존에 메모리를 올라와 있는 페이지 중 하나를 디스크로 스왑 아웃 시킨다.
- 요청된 페이지를 디스크로부터 메모리로 적재하기까지는 오랜 시간이 소요되므로 페이지 부재를 발생시킨 프로세스는 CPU를 째앗기고 봉쇄 상태가 된다.
- 현재까지 수행되던 CPU 레지스터 상태 및 프로그램 카운터값을 프로세스 제어블록에 저장해둠으로써 나중에 이 프로세스가 다시 CPU를 할당받았을 때 정확히 같은 상태에서 다음 명령을 수행할 수 있도록 한다.
- 디스크 입출력이 완료되어 인터럽트가 발생하면 페이지 테이블에서 해당 페이지의 유효-무효 비트를 유효로 설정하고, 봉쇄되었던 프로세스를 준비 큐로 이동시킨다.
- 이 프로세스가 다시 CPU를 할당받으면 프로세스 제어블록에 저장해두었던 값을 복원시켜 이전에 중단되었던 명령부터 실행을 재개한다.



#### 요구 페이징의 성능

- 가장 크게 영향을 미치는 요소는 페이지 부재의 발생 빈도

  - 페이지 부재가 일어나면 요청된 페이지를 디스크로부터 메모리로 읽어오는 막대한 오버헤드가 발생하기 때문

- 페이지 부재가 적게 발생할수록 요구 페이징의 성능은 향상될 수 있음

- 유효 접근 시간 = (1-P) * 메모리 접근 시간 

  ​							+ P*(페이지 부재 발생 처리 오버헤드

  ​							+메모리에 빈 프레임이 없는 경우 스왑 아웃 오버헤드

  ​							+요청된 페이지의 스왑 인 오버헤드

  ​							+프로세스의 재시작 오버헤드)

- 페이지 부재 발생 비율 : 0<=P<=1

  P=0 : 페이지 부재가 한번도 일어나지 않은 경우

  P=1 : 모든 참조 요청에서 페이지 부재가 발생한 경우



### 2. 페이지 교체

- 페이지 교체 : 메모리에 올라와 있는 페이지 중 하나를 디스크로 스왑 아웃 시켜 메모리에 빈 공간을 확보하는 작업
- 교체 알고리즘 : 페이지 교체를 할 때에 어떠한 프레임에 있는 페이지를 쫓아낼 것인지 결정하는 알고리즘
  - 페이지 부재율을 최소화하는 것이 목표
  - 따라서 가까운 미래에 참조될 가능성이 가장 적은 페이지를 선택해서 내쫓는 것이 성능을 향상시킬 수 있는 방안
  - 주어진 페이지 참조열에 대해 페이지 부재율을 계산함으로써 평가할 수 있음