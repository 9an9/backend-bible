# 메모리 관리



### 1. 주소 바인딩

<span style='background-color:#FFF8BC'>**논리적 주소**</span> : 프로그램이 실행을 위해 메모리에 적재되었을 때 그 프로세스를 위한 독자적인 주소공간.

​	- 각 프로세스마다 독립적으로 할당되며 0번지부터 시작

<span style='background-color:#FFF8BC'>**물리적 주소**</span> : 물리적 메모리에 실제로 올라가는 위치

​	- 보통 낮은 주소 영역에는 운영체제가 올라가고, 높은 주소 영역에는 사용자 프로세스들이 올라간다.

#### 주소 바인딩

> 프로세스의 논리적 주소를 물리적 메모리 주소로 연결시켜주는 작업



#### 방식

(프로그램이 적재되는 물리적 메모리의 주소가 결정되는 시기에 따라)

- 컴파일 타임 바인딩 : 물리적 메모리 주소가 프로그램을 컴파일할 때 결정됨
  - 컴파일을 하는 시점에 해당 프로그램이 물리적 메모리의 몇 번지에 위치할 것인지 결정
  - 절대코드 생성 바인딩 방식
  - 프로그램이 올라가 있는 물리적 메모리의 위치를 변경하고 싶으면 컴파일을 다시 해야 함
  - 비현실적이고 현대의 시분할 컴퓨팅 한경에서 잘 사용하지 않음
- 로드 타임 바인딩 : 프로그램의 실행이 시작될 때에 물리적 메모리 주소가 결정
  - 로더의 책임하에 물리적 메모리 주소가 부여되며 프로그램이 종료될 때까지 물리적 메모리상의 위치 고정
  - 로더 : 사용자 프로그램을 메모리에 적재시키는 프로그램
  - 컴파일러가 재배치 가능 코드를 생성한 경우에 가능한 주소 바인딩 방식
- 실행시간 바인딩 : 프로그램이 실행을 시작한 후에도 그 프로그램이 위치한 물리적 메모리상의 주소가 변경될 수 있는 바인딩 방식
  - CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지, 주소 매핑 테이블을 이용해 바인딩을 점검해야 함
  - 다른 방식들과 달리 <span style='background-color:#FFF8BC'>기준 레지스터</span>와 <span style='background-color:#FFF8BC'>한계 레지스터</span>를 포함해 MMU(메모리 관리 유닛)라는 하드웨어적인 지원이 뒷받침 되어야 함
  - <span style='background-color:#FFF8BC'>MMU</span> : 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치

#### MMU 기법 

- CPU가 특정 프로세스의 논리적 주소를 참조하려고 할 때 MMU 기법은 그 주소값에 기준 레지스터의 값을 더해 물리적 주소값을 얻어낸다
- 이때 기준 레지스터는 재배치 레지스터라고도 부르며 그 프로세스의 물리적 메모리 시작 주소를 가지고 있다.
- MMU 기법에서는 프로그램의 주소 공간이 물리적 메모리의 한 장소에 연속적으로 적재되는 것으로 가정한다.

#### 한계 레지스터

- 다중 프로그래밍 환경에서 MMU 방식을 사용하여 주소 변환을 했을 경우 CPU가 요청한 논리적 주소값과 재배치 레지스터 안에 있는 값을 더한 결과가 해당 프로세스의 주소 공간을 벗어나게 되어 메모리 보안이 이루어지지 않을 수 있다.

- 이를 방지하기 위해 한계 레지스터를 사용한다.

- 프로세스가 자신의 주소 공간을 넘어서는 메모리 참조를 하려고 하는지 체크하는 용도로 사용
- 현재 CPU에서 수행 중인 프로세스의 논리적 주소의 최댓값(프로세스의 크기)를 담고 있다.

#### 메모리 보안을 달성하는 방법

- CPU가 요청한 프로세스의 논리적 주소값이 한계 레지스터 내에 저장된 프로세스의 크기보다 작은지 확인
  - 작다면 논리적 주소값에 재배치 레지스터값을 더해 물리적 주소를 구한 다음 해당 물리적 메모리 위치에 접근하도록 허락 
  - 반면 논리적 주소값이 한계 레지스터의 값보다 크다면 프로세스가 존재하는 물리적 메모리의 바깥 부분, 다시 말하면 다른 프로세스의 주소 영역에 접근하려는 시도이므로 트랩을 발생시켜 해당 프로세스 강제 종료

### 2. 메모리 관리와 관련된 용어

#### 동적로딩

- 다중 프로그래밍 환경에서 메모리 사용의 효율을 높이기 위해 사용하는 기법 중 하나
- 프로세스 내에서 실행에 필요한 부분이 실제로 불릴 때마다 메모리에 적재
- 운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능
- 운영체제가 라이브러리를 통해 지원 가능

#### 동적연결

- 연결(linking) : 프로그래머가 작성한 소스 코드를 컴파일하여 생성된 목적 파일과 이미 컴파일된 라이브러리 파일들을 묶어  하나의 실행파일을 생성하는 과정
- 동적 연결 : 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 프로그램의 실행 시점까지 지연시키는 기법
- 정적 연결 : 프로그래머가 작성한 코드와 라이브러리 코드가 모두 합쳐져서 실행파일이 생성됨
  - 따라서 실행파일의 크기가 상대적으로 크며, 동일한 라이브러리를 각 프로세스가 개별적으로 메모리에 적재해야 하므로 물리적 메모리 낭비
- 동적연결을 가능하게 하기 위해 실행파일의 라이브러리 호출 부분에 해당 라이브러리의 위치를 찾기 위한 스텁이라는 작은 코드를 둔다.
  - 라이브러리 호출 시 스텁을 통해 해당 라이브러리가 메모리에 이미 존재하는지 살펴보고 그럴 경우 그 주소의 메모리 위체에서 직접 참조하며, 그렇지 않을 경우 디스크에서 동적 라이브러리 파일을 찾아 메모리로 적재한 후 수행
- 다수의 프로그램이 공통으로 사용하는 라이브러리를 메모리에 한번만 적재하므로 메모리 효율성을 높일 수 있음
- 운영체제의 지원을 필요로 함

#### 중첩

- 프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재하는 기법
- 동적로딩과 개념적으로 유사하지만 목적이 다름
- 중첩은 초창기의 컴퓨터 시스템에서 물리적 메모리 크기 제약으로 인해 하나의 프로세스조차도 메모리에 한꺼번에 올릴 수 없을 때 프로세스의 주소 공간을 분할해서 당장 필요한 일부분을 메모리에 올려 실행하고 해당 부분에 대한 실행이 끝난 후 나머지 부분을 올려 실행하는 기법
- 프로그램의 크기가 물리적 메모리의 크기에 비해 작다면 주소 공간 전체를 한번에 올릴 수 있지만 그렇지 않다면 분할해 메모리에 올림
- 운영체제의 지원 없이 프로그래머에 의해 구현

#### 스와핑

- 메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역에 일시적으로 내려놓는것
- 스왑 영역은 백킹스토어라고도 부르며 디스크 내에 파일 시스템과는 별도로 존재하는 일정 영역
- 프로세스가 수행 중인 동안에만 디스크에 일시적으로 저장하는 공간이므로 저장 기간이 상대적으로 짧음
- 다수의 사용자 프로세스를 담을 수 있을 만큼 충분히 큰 저장공간이어야 하고 어느 정도의 접근 속도가 보장되어야 함
- 프로세스가 종료되어 그 주소 공간을 디스크로 내쫓는 것이 아닌, 특정한 이유로 수행 중인 프로세스의 주소 공간을 일시적으로 메모리에서 디스크로 내려놓는 것
- 과정 
  - 스와퍼라고 불리는 중기 스케줄러에 의해 스왑아웃시킬 프로세스 선정
  - 스왑 아웃 대상으로 선정된 프로세스에 대해서는 현재 메모리에 올라가 있는 주소 공간의 내용을 통째로 디스크 스왑 영역에 스왑 아웃시키게 됨
- 메모리에 존재하는 프로세스의 수를 조절하는 중요한 역할(다중 프로그래밍의 정도를 조절)
- 컴파일 타임 바인딩 방식과 로드 타임 바인딩 방식에서는 스왑 아웃된 프로세스가 다시 스왑 인될 때에는 원래 존재하던 메모리 위치로 다시 올라가야 하지만 실행시간 바인딩 기법에서는 추후 빈 메모리 영역 아무 곳에나 프로세스를 올릴 수 있음
- 보통 디스크 내의 스왑 영역에 프로세스의 주소 공간이 순차적으로 저장되기 때문에 스와핑에 소요되는 시간은 디스크의 탐색시간이나 회전지연시간보다는 디스크 섹터에서 실제 데이터를 읽고 쓰는 전송 시간이 대부분을 차지



### 3. 물리적 메모리의 할당 방식(사용자 프로세스 영역)

#### 연속할당 방식

- 프로세스를 메모리에 올릴 때 그 주소 공간을 여러 개로 분할하지 않고 물리적 메모리의 한 곳에 연속적으로 적재하는 방식

  **고정분할 방식**

  - 물리적 메모리를 주어진 개수만큼의 영구적인 분할로 미리 나누어두고 각 분할에 하나의 프로세스를 적재해 실행시킬 수 있게 함
  - 분할의 크기는 모두 동일하게 할 수도 있고 서로 다르게 할 수도 있음
  - 하나의 분할에는 하나의 프로그램만 적재 가능
  - 동시에 메모리에 올릴 수 있는 프로그램의 수가 고정되어 있으며 수행 가능한 프로그램의 최대 크기 또한 제한 된다는 점에서 융통성이 떨어짐
  - <span style='background-color:#FFF8BC'>외부조각과 내부조각 발생</span>
  - 외부조각 : 프로그램의 크기보다 분할의 크기가 작은 경우 해당 분할이 비어 있는데도 불구하고 프로그램을 적재하지 못하기 때문에 발생하는 메모리 공간
    - 특정 프로그램에 배당된 공간이 아니기 때문에 이 외부조각의 크기보다 작은 크기의 프로그램이 도착한다면 그 프로그램을 외부조각에 적재 가능
  - 내부조각 : 프로그램의 크기보다 분할의 크기가 큰 경우 해당 분할에 프로그램을 적재하고 남은 메모리 공간
    - 특정 프로그램에 이미 배당된 공간으로 볼 수 있으므로 내부조각에 수용할 수 있는 크기의 프로그램이 있더라도 공간을 활용할 수 없어 메모리 낭비

  **가변 분할 방식**

  - 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식
  - 내부조각이 발생하지는 않지만 이미 메모리에 존재하는 프로그램이 종료될 경우 중간에 빈 공간이 발생하게 되며 이 공간이 새롭게 시작되는 프로그램의 크기보다 작을 경우 <span style='background-color:#FFF8BC'>외부조각 발생</span>
    - 컴팩션 : 물리적 메모리 중에서 프로세스에 의해 사용 중인 메모리 영역을 한쪽으로 몰고 가용 공간들을 다른 한쪽으로 모아서 하나의 큰 가용 공간을 만드는 방법
  - <span style='background-color:#FFF8BC'>동적 메모리 할당 문제</span> : 주소 공간의 크기가 n인 프로세스를 메모리에 올릴 때 물리적 메모리 내 가용 공간 중 어떤 위치에 올릴 것인지 결정하는 문제
    - 가용 공간이란 사용되지 않은 메모리 공간으로서 메모리 내의 여러 곳에 산발적으로 존재할 수 있다.
    - 해결방법
      1. 최초 적합 방법 : 크기가 n 이상인 가용 공간 중 가장 먼저 찾아지는 곳에 프로세스를 할당
         - 메모리에 존재하는 가용 공간을 차례대로 살펴보면서 가용 공간이 프로그램 크기보다 작으면 건너뛰고 그렇지 않은 가용 공간이 최초로 발견되면 그 공간에 프로그램을 올림
         - 가용 공간 모두를 탐색하지 않으므로 시간적인 측면에서 효율적
      2. 최적 적합 방법 : 크기가 n이상인 가장 작은 가용 공간을 찾아 그곳에 새로운 프로그램을 할당
         - 가용 공간들의 리스트가 크기순으로 정렬되어 있지 않은 경우에 모든 가용 공간 리스트를 탐색해야 하므로 시간적 오버헤드가 발생하고 다수의 매우 작은 가용공간들이 생성될 수 있다는 단점이 있지만 공간적인 측면에서 효율적
      3. 최악 적합 방법 : 가용 공간 중에서 가장 크기가 큰 곳에 새로운 프로그램을 할당
         - 모든 가용 공간 리스트를 탐색해야 하는 오버헤드가 발생하며 상대적으로 더 큰 프로그램을 담을 수 있는 가용 공간을 빨리 소진한다는 문제가 있음

#### 불연속할당 방식

- 하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라갈 수 있는 메모리 할당 기법
- 페이징 기법 : <span style='background-color:#FFF8BC'>동일한 크기</span>로 나누어 메모리에 올림
- 세그먼테이션 기법 : 크기는 일정하지 않지만 <span style='background-color:#FFF8BC'>의미 단위</span>로 나누어 메모리에 올림
- 페이지드 세그먼테이션 기법 : 세그먼테이션을 기본으로 하되 이를 다시 동일 크기의 페이지로 나누어 메모리에 올림



### 4. 페이징 기법

- 페이징 기법 : 프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지들을 저장하는 방식

- 각 프로세스의 주소 공간 전체를 물리적 메모리에 한꺼번에 올릴 필요가 없으며, 일부는 백킹스토어에, 일부는 물리적 메모리에 혼재시키는 것이 가능

- 물리적 메모리를 페이지와 동일한 크기의 프레임으로 미리 나누어둔다.

- 메모리에 올리는 단위가 동일한 크기의 페이지 단위이므로, 메모리를 같은 크기로 미리 분할해두더라도 빈 프레임이 있으면 어떤 위치든 사용될 수 있기 때문에 연속 할당에서 발생했던 동적 메모리 할당 문제가 발생하지 않는다는 장점

- 주소변환 절차가 복잡 
  -  모든 프로세스가 각각의 주소 변환을 위한 페이지 테이블을 가지며, 이 테이블은 프로세스가 가질 수 있는 페이지의 개수만큼 주소 변환 엔트리를 가지고 있게 됨

- 프로세스의 주소 공간과 물리적 메모리가 모두 같은 크기의 페이지 단위로 나누어지기 때문에 외부조각 문제가 발생하지 않지만 프로그램의 크기가 항상 페이지 크기의 배수가 된다는 보장이 없기 때문에 프로세스의 주소 공간 중 제일 마지막에 위치한 페이지는 <span style='background-color:#FFF8BC'>내부조각이 발생할 가능성</span>이 있다.

#### 1. 주소 변환 기법

- 페이징 기법에서는 CPU가 사용하는 논리적 주소를 페이지 번호(p)와 페이지 오프셋(d)으로 나누어 주소변환에 사용함
- 페이지 번호는 각 페이지별 주소 변환 정보를 담고 있는 페이지 테이블 접근 시 인덱스로 사용되고 해당 인덱스의 항목에는 그 페이지의 물리적 메모리상의 기준 주소, 즉 시작 위치가 저장됨
- 특정 프로세스의 p번쨰 페이지가 위치한 물리적 메모리의 시작 위치를 알고 싶다면 해당 프로세스의 페이지 테이블에서 p번째 항목을 찾아보면 됨
- 페이지 오프셋은 하나의 페이지 내에서의 변위를 알려줌
- 기준 주소값에 변위를 더함으로써 요청된 논리적 주소에 대응하는 물리적 주소를 얻을 수 있음

#### 2. 페이지 테이블의 구현

- <span style='background-color:#FFF8BC'>페이지 테이블</span> : 페이징 기법에서 주소 변환을 하기 위한 자료구조로 물리적 메모리에 위치
- 페이지 테이블 기준 레지스터 : 메모리 내에서의 페이지 테이블의 시작 위치를 가리킴
- 페이지 테이블 길이 레지스터 : 페이지 테이블의 크기 보관
  - 하나의 프로세스를 구성하는 모든 페이지에 대한 주소 변환 정보가 페이지 번호에 따라 순차적으로 들어 있기 때문에 페이지 번호가 주어지면 테이블의 시작 위치에서 페이지 번호만큼 떨어진 항목에 곧바로 접근해 해당 페이지에 대응되는 프레임 번호를 얻을 수 있음

##### TLB(Translation Look-aside Buffer)

- 페이지 기법에서 메모리 접근 연산은 주소 변환을 위해 페이지 테이블에 접근, 변환된 주소에서 실제 데이터에 접근, 이렇게 메모리에 한번 접근하기 위해 매번 메모리에 두번 접근해야 하기 때문에 오버헤드 발생

- <span style='background-color:#FFF8BC'>오버헤드를 줄이고 메모리 접근 속도를 향상시키기 위해</span> TLB(Translation Look-aside Buffer)라고 불리는 고속의 주소 변환용 하드웨어 캐시가 사용되기도 함

- 프로세스의 모든 페이지에 대한 정보를 TLB가 가지고 있지 않기 때문에 페이지 번호와 이에 대응하는 프레임 번호가 쌍으로 저장되어 있어야 함

- 해당 페이지에 대한 주소 변환 정보가 TLB에 있는지 확인하기 위해 TLB의 모든 항목을 다 찾아봐야 하는 오버헤드 발생

- 오버헤드를 줄이기 위해 일반적으로 병렬탐색이 가능한 연관 레지스터 사용
  - 병렬탐색 기능 : TLB 내의 모든 항목을 동시에 탐색할 수 있는 기능

- 연관 레지스터를 사용할 때 평균적인 메모리 접근 시간 2+e-a

#### 3. 계층적 페이징

- 페이지 테이블에 사용되는 메모리 공간의 낭비를 줄이기 위해 2단계 페이징 기법 사용
- 프로세스의 주소 공간이 커질수록 페이지 테이블의 크기도 커지므로 주소 변환을 위한 메모리 공간 낭비 역시 심각해지기 때문에 다단계 페이지 테이블 필요
- 메모리 접근에 의한 시간적인 오버헤드를 줄이기 위해서는 TLB 사용
- 다단계 페이지 테이블로 인해 공간적 이득을 얻을 수 있으며 동시에 메모리 접근시간도 그다지 늘어나지 않아 시간적 효율성 또한 얻을 수 있음

##### 2단계 페이징 기법

- 주소 변환을 위해 외부 페이지 테이블과 내부 페이지 테이블을 사용사용되지 않는 주소 공간에 대해서는 외부페이지 테이블의 항목을 null로 설정하며 여기에 대응하는 내부 페이지 테이블을 생성하지 않음
- 주소 변환을 위해 접근해야 한ㄴ 페이지 테이블의 수가 증가하므로 시간적 손해



#### 4. 역페이지 테이블

- 모든 프로세스의 모든 페이지에 대해 페이지 테이블 항목을 다 구성해야 하기 때문에 페이지 테이블로 인한 메모리 공간의 낭비가 심함

- 역페이지 테이블 기법 : 물리적 메모리의 페이지 프레임 하나당 페이지 테이블에 하나씩의 항목을 두는 방식

- 논리적 주소에 대해 페이지 테이블을 만드는 것이 아니라 물리적 주소에 대해 페이지 테이블을 만듬

- 각 프로세스마다 페이지 테이블을 두지 않고 시스템 전체에 페이지 테이블을 하나만 두는 방법

- 물리적 주소로부터 논리적 주소를 얻기 수월한 구조

- 주소 변환이 다소 비효율적 

  - 주소 변환 요청이 들어오면 그 주소를 담은 페이지가 물리적 메모리에 존재하는지 여부를 판단하기 위해 페이지 테이블 전체를 탐색해야 함

  - 일반적으로 메모리에 유지하는 대신 연관 레지스터에 보관해 테이블 전체 항목에 대한 병렬탐색을 가능하게 함으로서 시간적 효율성을 높임

#### 5. 공유 페이지

- 공유 코드 : 메모리 공간의 효율적인 사용을 위해 여러 프로세스에 의해 공통으로 사용될 수 있도록 작성된 코드
  - 재진입 가능 코드, 순수코드라고도 불림
  - 읽기전용
  - 모든 프로세스의 논리적 주소 공간에서 동일한 위치에 존재해야 함
  - 그 페이지를 공유하는 모든 프로세스의 주소 공간에서 동일한 페이지 번호를 가져야 함
- 공유 페이지 : 공유 코드를 담고 있는 페이지
- 사유 페이지 : 프로세스들이 공유하지 않고 프로세스별로 독자적으로 사용하는 페이지

#### 6. 메모리 보호

- 페이지 테이블의 각 항목에는 메모리 보호를 위한 보호비트와 유효-무효 비트를 두고 있음
- <span style='background-color:#FFF8BC'>보호비트</span>는 각 페이지에 대한 접근 권한의 내용을 담고 있음
  - 한 프로세스의 주소 공간은 다른 프로세스에 의해 접근될 수 없으므로 '누구'에 해당하는 접근 권한 설정은 필요 없으며 각 페이지에 대해 '어떠한' 접근을 허용하는지의 정보가 보호비트에 저장
  - 각 페이지에 대해 읽기-쓰기/읽기전용 등의 접근 권한을 설정하는 데에 사용
- <span style='background-color:#FFF8BC'>유효-무효 비트</span>는 해당 페이지의 내용이 유효한지에 대한 내용을 담고 있음
  - 유효로 세팅되어 있으면 해당 메모리 프레임에 그 페이지가 존재함을 뜻하며 접근 허용
  - 무효로 세팅되어 있으면 프로세스가 그 주소 부분을 사용하지 않거나 해당 페이지가 물리적 메모리에 올라와 잇지 않고 백킹스토어에 존재해 해당 메모리 프레임에 유효한 접근 권한이 없다는 의미



### 5. 세그먼테이션

- 세그먼트 : 주소 공간을 기능 단위 또는 의미 단위로 나눈 것
- 일반적으로 프로세스의 주소 공간을 코드, 데이터, 스택 등의 기능 단위로 세그먼트 정의
- 세그먼트가 특정 크기 단위로 나눈 것이 아니라 의미를 가질 수 있는 논리적인 단위로 나눈 것이기 때문에 크기가 균일하지 않음
- 프로세스의 주소 공간이 나누어져 각각 메모리에 적재된다는 점에서 페이징 기법과 유사
- 프로그램을 의미 단위의 세그먼트로 나누어 관리하므로 크기가 균일하지 않은 세그먼트들을 메모리에 적재하는 부가적인 관리 오버헤드
- 논리적 주소가 <세그먼트 번호, 오프셋>으로 나뉘어 사용
  - 세그먼트 번호 : 해당 논리적 주소가 프로세스 주소 공간 내에서 몇 번째 세그먼트에 속하는지
  - 오프셋 : 그 세그먼트 내에서 얼마만큼 떨어져 있는지
- 주소 변환을 위해 세그먼트 테이블 사용
  - 각 항목은 기준점(물리적 메모리에서 그 세그먼트의 시작 위치)과 한계점(그 세그먼트의 길이)을 가짐
  - 길이가 균일하지 않으므로 길이 정보를 가짐
- 주소 변환 시 세그먼트 테이블 기준 레지스터와 세그먼트 테이블 길이 레지스터 사용
  - 세그먼트 테이블 기준 레지스터(STBR) : 현재 CPU에서 실행 중인 프로세스의 세그먼트 테이블이 메모리의 어느 위치에 있는지 시작 주소를 담고 있음
  - 세그먼트 테이블 길이 레지스터(STLR) : 그 프로세스의 주소 공간이 총 몇 개의 세그먼트로 구성되는지, 세그먼트의 개수
- 논리적 주소를 물리적 주소로 변환하기 전에 
  - 요청된 세그먼트 번호가 STLR에 저장된 값보다 작은지 확인
    - 그렇지 않다면 존재하지 않는 세그먼트에 대한 접근 시도이므로 예외상황을 발생시켜 메모리 접근 봉쇄
  - 논리적 주소의 오프셋값이 그 세그먼트의 길이보다 작은 값인지 확인
    - 세그먼트 테이블의 해당 항목에 있는 한계점과 요청된 논리적 주소의 오프셋값을 비교해 확인
    - 세그먼트 길이를 넘어서는 오프셋 위치에 대한 접근 시도이면 예외상황 발생
- 세그먼트 테이블의 각 항목에
  - 보호비트 : 각 세그먼트에 대해 읽기/쓰기/실행 등의 권한이 있는지
  - 유효비트 : 각 세그먼트의 주소 변환 정보가 유효한지 (해당 세그먼트가 현재 물리적 메모리에 적재되어 있는지)
- 공유 세그먼트
  - 이 세그먼트를 공유하는 모든 프로세스의 주소 공간에서 동일한 논리적 주소에 위치해야 함
- 의미 단위로 나누어져 있기 때문에 공유와 보안 측면에서 페이징 기법에 비해 효과적
- 세그먼트를 어느 가용 공간에 할당할 것인지 결정하는 문제 발생 -> 최초적합 방식, 최적적합방식



### 6. 페이지드 세그먼테이션

- 페이지 기법과 세그먼테이션 기법의 장점만을 취한 주소 변환 기법
- 프로그램을 의미 단위의 세그먼트로 나누지만 이 세그먼트가 동일한 크기 페이지들의 집합으로 구성
- 하나의 세그먼트 크기를 페이지 크기의 배수가 되도록 함으로써 세그먼테이션 기법에서 발생하는 외부조각의 문제점을 해결하며, 동시에 세그먼트 단위로 프로세스 간의 공유나 프로세스 내의 접근 권한 보호가 이루어지도록 함으로써 페이징 기법의 약점 해소
- 주소 변환을 위해 외부의 세그먼트 테이블과 내부의 페이지 테이블, 두 단계의 테이블 사용
- 각 세그먼트마다 페이지 테이블을 가짐
- 과정
  - 존리적 주소의 상위 비트인 세그먼트 번호를 통해 세그먼트 테이블의 해당 항목에 접근(세그먼트 길이, 세그먼트의 페이지 테이블 시작 주소)
  - 세그먼트 길이를 넘어서는 메모리 접근 시도인지 여부 체크
    - 세그먼트 길이값과 논리적 주소 중 하위 비트인 오프셋값 비교
    - 오프셋 값이 더 크다면 트랩 발생, 아니면 오프셋값을 다시 상위/하위 비트로 나눙 상위 비트는 세그먼트 내에서의 페이지 번호로 사용하고 하위 비트는 페이지 내에서의 변위로 사용
  - 세그먼트 테이블의 항목을 통해 얻은 페이지 테이테이블의 시작위치에서 페이지 번호만큼 떨어진 페이지 테이블 항목으로부터 물리적 메모리의 페이지 프레임의 위치를 얻음
  - 이  위치에서 오프셋의 하위 비트값인 페이지 내 변위만큼 떨어진 곳이 원하는 물리적 메모리 주소



