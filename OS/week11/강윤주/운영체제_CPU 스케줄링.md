> CPU : 프로그램의 기계어 명령을 실제로 수행하는 컴퓨터 내의 중앙처리장치.

#### 기계어 명령 

- CPU 내에서 수행되는 명령
  - Add 명령 : CPU 내의 레지스터에 있는 두 값을 더해 레지스터에 저장하는 명령
  - CPU 내에서만 수행되므로 명령의 수행 속도가 매우 빠름
  - 일반명령(사용자가 직접 실행 가능)
- 메모리 접근을 필요로 하는 명령
  - Load 명령 : 메모리에 있는 데이터를 CPU로 읽어들이는 명령
  - Store 명령 : CPU에서 계산된 결괏값을 메모리에 저장하는 명령
  - CPU 내에서 수행되는 명령보다는 시간이 오래 소요되지만 비교적 짧은 시간에 수행할 수 있음
  - 일반명령(사용자가 직접 실행 가능)
- 입출력을 동반하는 명령
  - 오랜 시간 소요
  - 특권명령(사용자가 실행할 수 없고 운영체제가 서비스를 대행)

#### 프로그램의 수행

1. CPU 버스트(burst) : 사용자 프로그램이 CPU를 직접 가지고 빠른 명령을 수행하는 일련의 단계
   - 프로그램이 I/O를 한번 수행한 후 다음 번 I/O를 수행하기까지 직접 CPU를 가지고 명령을 수행하는 일련의 작업
2. I/O 버스트(burst) : I/O 요청이 발생해 커널에 의해 입출력 작업을 진행하는 비교적 느린 단계
   - I/O 작업이 요청된 후 완료되어 다시 CPU 버스트로 돌아가기까지 일어나는 일련의 작업



#### CPU 버스트와 I/O 버스트가 차지하는 비율에 따른 프로세스

- I/O 바운드 프로세스(I/O bound process) : I/O 요청이 빈번해 CPU 버스트가 짧게 나타나는 프로세스
  - 주로 사용자로부터 인터랙선을 계속 받아가며 프로그램을 수행시키는 대화형 프로그램(interactive program)
  - 짧은 CPU 버스트를 많이 가짐
- CPU 바운드 프로세스(CPU bound process) : I/O 작업을 거의 수행하지 않아 CPU 버스트가 길게 나타나는 프로세스
  - 프로세스 수행의 상당 시간을 입출력 작업 없이 CPU 작업에 소모하는 계산 위주의 프로그램
  - 소수의 긴 CPU 버스트로 구성
- CPU 스케줄링 시 I/O 바운드 프로세스의 우선순위를 높여주는 것이 바람직
  - 대화형 프로세스의 빠른 응답성 제공 외에 I/O 장치의 효율성을 놓일 수 있음



### CPU 스케줄러

> CPU 스케줄러 : 준비 상태에 있는 프로세스들 중 어떠한 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드

- 비선점형 방식(nonpreemptive) : CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지는 CPU를 빼앗기지 않는 방법
- 선점형 방식(preemptive) : 프로세스가 CPU를 계속 사용하기를 원하더라도 강제로 빼앗을 수 있는 스케줄링 방법
  - 할당시간(time quantum)을 부여한 후 타이머 인터럽트를 발생시키는 방법이 대표적

 - 실행 상태에 있던 프로세스가 I/O 요청 등에 의해 봉쇄 상태로 바뀌는 경우 - <span style="background-color:#E8F9FD">비선점형 스케줄링</span>
 - 실행 상태에 있던 프로세스가 타이머 인터럽트 발생에 의해 준비 상태로 바뀌는 경우 - <span style="background-color:#E8F9FD">선점형 스케줄링</span>
 - I/O 요청으로 봉쇄 상태에 있던 프로세스의 I/O 작업이 완료되어 인터럽트가 발생하고 그 결과 이 프로세스의 상태가 준비 상태로 바뀌는 경우 - <span style="background-color:#E8F9FD">선점형 스케줄링</span>
   - 이번에 I/O 작업이 완료된 프로세스가 인터럽트 당한 프로세스보다 우선순위가 높아, 인터럽트 처리 후 직전에 수행되던 프로세스에게 CPU를 다시 할당하는 것이 아닌 문맥교환을 통해 I/O가 완료된 프로세스에게 CPU를 할당하는 경우
 - CPU에서 실행 상태에 있는 프로세스가 종료되는 경우 - <span style="background-color:#E8F9FD">비선점형 스케줄링</span>



### 디스패처

> 디스패처(dispatcher) : 새롭게 선택된 프로세스가 CPU를 할당받고 작업을 수행할 수 있도록 환경설정을 하는 운영체제의 코드

	- 현재 수행 중이던 프로세스의 문맥을 그 프로세스의 PCB에 저장하고, 새롭게 선택된 프로세스의 문맥을 PCB로부터 복원한 후 그 프로세스에게 CPU를 넘기는 과정을 수행
 - 디스패치 지연시간(dispatch latency) :디스패처가 하나의 프로세스를 정지시키고 다른 프로세스에게 CPU를 전달하기까지 걸리는 시간
   - 대부분은 문맥교환 오버헤드에 해당



### 스케줄링의 성능 평가

#### 시스템 관점의 지표

- CPU 이용률 (CPU utilization)
  - 전체 시간 중에서 CPU가 일을 한 시간의 비율
  - CPU가 일을 하지 않고 휴면(idle) 상태에 머무르는 시간을 최대한 줄이는 것이 스케줄링의 중요한 목표
- 처리량(throughput)
  - 주어진 시간 동안 준비 큐에서 기다리고 있는 프로세스 중 몇 개를 끝마쳤는지(CPU 버스트를 완료한 프로세스의 개수)
  - CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 할당하는 것이 유리

#### 사용자 관점의 지표(기다린 시간과 관련된 지표)

- 소요시간(turnaround time) 
  - 프로세스가 CPU를 요청한 시점부터 자신이 우너하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때까지 걸린 시간, 즉 준비 큐에서 기다린 시간과 실제로 CPU를 사용한 시간의 합
  - 프로그램이 시작해 종료하는 데까지 걸리는 시간이 아닌, 해당 CPU 버스트가 완료될 때까지 소요된 시간
  - 하나의 프로세스라 하더라도 소요시간은 CPU 버스트의 수만큼 각각 별도로 측정
- 대기시간(waiting time)
  - CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합
  - 이번 CPU 버스트가 끝나기까지 준비 큐에서 기다린 시간의 합
- 응답시간(response time)
  - 프로세스가 준비 큐에 들어온 후 첫번째 CPU를 획득하기까지 기다린 시간
  - 대화형 시스템에 적합한 성능 척도로서 사용자 입장에서 가장 중요한 성능 척도



### 스케줄링 알고리즘

1. 선입선출(FCFS)
   - 프로세스가 준비 큐에 도착한 시간 순서대로 CPU를 할당
   - 먼저 도착한 프로세스의 성격에 따라 평균 대기시간이 크게 달라짐
   - 콘보이 현상(Convoy effect) : CPU 버스트가 짧은 프로세스가 CPU 버스트가 긴 프로세스보다 나중에 도착해 오랜 시간을 기다려야 하는 현상. FCFS 스케줄링의 대표적인 단점
2. 최단작업 우선 스케줄링(SJF)
   - CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식
   - 평균 대기시간을 가장 짧게 하는 최적 알고리즘
   - 비선점형 방식 : 일단 CPU를 획득하면 그 프로세스가 CPU를 자진 반납하기 전까지는 CPU를 빼앗지 않는 방식
   - 선점형 방식(SRTF:Shortest Rmaining Time First) : 준비 큐에서 CPU 버스트가 가장 짧은 프로세스에게 CPU를 할당했다 하더라도 CPU 버스트가 더 짧은 프로세스가 도착할 경우 CPU를 빼앗아 더 짧은 프로세스에게 부여
     - 현재 CPU에서 실행 중인 프로세스의 남은 CPU 버스트 시간보다 더 짧은 CPU 버스트 시간을 가지는 프로세스가 도착할 경우 CPU를 빼앗게 됨
     - 프로세스들의 평균 대기시간을 최소화하는 최적의 알고리즘
   - 프로세스의 CPU 버스트 시간을 미리 알 수 없기 때문에 예측을 통해 CPU 버스트 시간을 구한 후 예측치가 가장 짧은 프로세스에게 CPU를 할당
   - 기아 현상(starvation) : CPU 버스트가 짧은 프로세스가 계속 도착할 경우 프로세스 A는 영원히 CPU를 할당받지 못할 수 있음
3. 우선순위 스케줄링
   - 준비 큐에서 기다리는 프로세스들 중 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당
   - 우선순위 값으로 표시하며 우선순위 값이 작을수록 높은 우선순위를 가진다고 가정
   - 비선점형 방식 : 일단 CPU를 얻었으면 우선순위가 더 높은 프로세스가 도착하더라도 CPU를 자진반납하기 전까지 선점하지 않음
   - 선점형 방식 : 현재 CPU에서 수행 중인 프로세스보다 우선순위가 높은 프로세스가 도착하여 CPU를 선점해서 새롭게 도착한 프로세스에게 할당
   - 기아 현상이 발생할 수 있음 
   - 노화(aging) 기법 : 기다리는 시간이 길어지면 우선순위를 조금씩 높임.
4. 라운드 로빈 스케줄링
   - 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간이 특정 시간으로 제한되며 이 시간이 경과하면 해당 프로세스로부터 CPU를 회수해 준비 큐에 줄 서있는 다른 프로세스에게 CPU를 할당
   - 할당시간 : 각 프로세스마다 한번에 CPU를 연속적으로 사용할 수 있는 최대시간
     - 너무 길면 선입선출 방식과 같은 결과를 나타내게 되며 너무 짧으면 문맥교환의 오버헤드가 커진다.
     - 일반적으로 수십 밀리초 정도의 규모로 설정하게 되며 이는 여러 프로세스가 동시에 수행되는 환경에서 대화형 프로세스가 CPU를 한 번 할당받기까지 지나치게 오래 기다리지 않을 정도의 시간 규모
   - SJF 방식보다 평균 대기시간은 길지만 응답시간은 더 짧음
     - SJF에 비해 공정한 스케줄링 방식
   - FCFS 방식에 비해 평균 대기시간 및 평균 소요시간이 더 길어지지만 평균 응답시간은 짧아짐
   - 프로세스의 CPU 사용량에 비례해 소요시간이 증하가게 되므로 매우 합리적
5. 멀티레벨 큐
   - 준비 큐를 여러 개로 분할해 관리하는 스케줄링 기법
   - 일반적으로 성격이 다른 프로세스들을 별도로 관리하고 프로세스의 성격에 맞는 스케줄링을 적용하기 위해 준비 큐를 별도로 둠
   - 전위 큐 : 대화형 작업
     - 응답시간을 짧게 하기 위한 라운드로빈 스케줄링
   - 후위 큐 : 계산 위주의 작업
     - 문맥교환 오버헤드를 줄이기 위한 FCFS
   - 큐 자체에 대한 스케줄링
     - 고정 우선순위 방식 : 큐에 고정적인 우선순위를 부여해 우선순위가 높은 큐를 먼저 서비스하고 우선순위가 높은 큐가 비어있을 경우에만 우선순위가 납은 큐를 서비스
     - 타임 슬라이스 방식 : 큐에 대한 기아 현상을 해소할 수 있는 방식으로 각 큐에 CPU 시간을 적절한 비율로 할당
6. 멀티레벨 피드백 큐
   - 프로세스를 여러 큐에 줄세운다는 측면에서 멀티 큐와 동일하나, 프로세스가 하나의 큐에서 다른 큐로 이동 가능
   - 노화 기법을 멀티레벨 피드백 큐 방식으로 구현 가능
   - 정의하는 요소 : 큐의 수, 각 큐의 스케줄링 알고리즘, 프로세스를 상위 큐로 승격시키는 기준, 프로세스를 하위 큐로 강등시키는 기준, 프로세스가 도착했을 떄 들어갈 큐를 결정하는 기준 등
   - 프로세스가 상위 큐에서 주어진 시간 안에 완료되지 않을 경우 하위 큐로 이동
7. 다중처리기 스케줄링
   - 다중처리기 시스템 : CPU가 여러개인 시스템
   - 큐를 한줄로 세워 각 CPU가 알아서 프로세스를 꺼내가 가도록 하는 경우
   - 각 CPU 별로 큐를 줄세우는 경우
     - 일부 CPU에 작업이 편중되는 현상이 발행할 수 있어 다중 처리기 스케줄링에서는 이를 방지하기 위한 부하균형 메커니즘을 필요로 함
   - 대칭형 다중처리 : 각 CPU가 각자 알아서 스케줄링
   - 비대칭형 다중처리 : 하나의 CPU가 다른 모든 CPU의 스케줄링 및 데이터 접근을 책임지고 나머지 CPU는 거기에 따라 움직임
8. 실시간 스케줄링
   - 실시간 시스템에서는 각 작업마다 주어진 데드라인이 있어 정해진 데드라인 안에 반드시 작업을 처리해야 함
   - EDF(Earlist Deadline First) 스케줄링 : 먼저 온 요청을 먼저 처리하기 보다는 데드라인이 얼마 남지 않은 요청을 먼저 처리



### 스케줄링 알고리즘 평가

- 큐잉모델 : 주로 이론가들이 수행하는 방식으로, 확률분포를 통해 프로세스들의 도착률과 CPU의 처리율을 입력값으로 주면 복잡한 수학적 계산을 통해 각종 성능지표인 CPU의 처리량, 프로세스의 평균 대기시간 등을 구함
- 시뮬레이션 : 실제 시스템에 구현해보는 것이 아닌 가상으로 CPU 스케줄링 프로그램을 작성한 후 프로그램의 CPU 요청을 입력값으로 넣어 어떠한 결과가 나오는지 확인
  - 트레이스(trace) : 실제 시스템에서 추출한 입력값으로 몇 초에 어떤 프로세스가 도착하고, 각각 CPU 버스트 시간을 얼마로 하는지에 대한 정보를 시간 순서대로 적어놓은 파일 
- 구현 및 실측 : 이론가와 정반대인 구현가들이 수행할 수 있는 방식으로 운영체제 커널의 소스 코드 중 CPU 스케줄링을 수행하는 코드를 수정해서 커널을 컴파일한 후 시스템에 설치하는 과정을 필요로 함. 그런 다음 동일한 프로그램을 원래 커널과 CPU 스케줄러를 수정한 커널에서 수행시켜보고 실행시간을 측정